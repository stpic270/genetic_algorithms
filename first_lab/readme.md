# Введение
Алгоритм Форда-Беллмана позволяет найти кратчайшие пути из одной вершины графа до всех остальных, даже для графов, в которых веса ребер могут быть отрицательными. Тем не менее, в графе не должно быть циклов отрицательного веса, достижимых из начальной вершины, иначе вопрос о кратчайших путях является бессмысленным. 
Введем некоторые понятия, которые будут важны в последующем отчете: 
Пло́тный граф — граф, в котором число рёбер E близко к максимально возможному у полного графа с числом вершин V:

E = V(V-1)2

Граф, имеющий малое число рёбер, принято называть разреженным графом.
Вообще говоря, разница между разреженным и плотным графом условна и зависит от контекста. 

# Выполненная работа 
Алгоритм Форда-Беллмана использует динамическое программирование. Введем функцию динамического программирования:
F[k][i] — длина кратчайшего пути из начальной вершины до вершины i, содержащего не более k ребер.
Начальные значения зададим для случая k=0. В этом случае F[0][start] = 0, а для всех остальных вершин i F[0][i] = INF, то есть путь, состоящий из нуля ребер существует только от вершины start до вершины start, а до остальных вершин пути из нуля ребер не существует, что будем отмечать значением INF.
Далее будем вычислять значения функции F увеличивая число ребер в пути k, то есть вычислим кратчайшие пути, содержащие не более 1 ребра, кратчайшие пути, содержащие не более 2 ребер и т. д.
Рассмотрим, как вычисляется значение F[k][i]. Пусть есть кратчайший маршрут из вершины start до вершины i, содержащий не более k ребер. Пусть последнее ребро этого маршрута есть ребро j-i. Тогда путь до вершины j содержит не более k-1 ребра и является кратчайшим путем из всех таких путей, значит, его длина равна F[k-1][j], а длина пути до вершины i равна F[k-1][j] + edges[j][i], где edges[j][i] есть вес ребра j-i. Дальше необходимо перебрать все вершины j, которые могут выступать в качестве предыдущих, и выбрать минимальное значение F[k-1][j] + edges[j][i]. Также edges реализован как python list и содержит веса ребер для плотного графа.

Получается следующий алгоритм: 

![image](https://user-images.githubusercontent.com/58371161/218878693-c1d0edc8-40ec-4dcb-85d4-59105ab3e3f7.png)

Рис. 1 - реализация с использованием python list для хранения весов ребер

Где  F - функция динамического программирования, описанная выше; k представляет собой ребро; i - вершину графа; j - переменная, необходимая для итерации по вершинам в функции F и весам в edges (в данном варианте является python list) .
Очевидно, что сложность такого алгоритма O(n3), т.к. подряд идут 3 вложенных цикла.

Рассмотрим реализацию алгоритма Форда-Беллмана с использованием списков смежности.
Пусть граф задан списками смежности, а вес ребра j-i хранится в словаре         W[j, i], где ключ — это кортеж из j, i, а значение — вес ребра. Тогда перебрать все ребра графа, можно организовав цикл по всем ключам словаря W и алгоритм Форда-Беллмана можно записать в виде:

![image](https://user-images.githubusercontent.com/58371161/218878562-05c23858-6f48-4c48-8c1b-8cad3159794c.png)

Рис. 2 - реализация с использованием python dict для хранения весов ребер

Здесь все переменные обозначают то же самое, что и на рис. 1, за исключением того, что в данном примере edges - python dict.

Сложность такого алгоритма равна O(mn) , где  n - число вершин, m - число ребер графа. Видно, что для плотных графов (где mn2) сложность близка к сложности предыдущего варианта алгоритма, а вот для разреженных графов (где mn ) такой алгоритм будет существенно быстрее.
Однако в данной работе сгенерированные тесты представляют собой только плотные графы, при этом python немного быстрее работает с объектами list, чем с объектами dict. Поэтому использование list, вместо dict для плотных графов, используя алгоритм Форда-Беллмана является некоторой оптимизацией данного метода при заданных условиях.

Время выполнения с вариантом python list при количестве вершин n = 150 = 0.44 с.

Время выполнения с вариантом python dict при количестве вершин n = 150 = 0.65 с.

# Выводы 

В данной работе был реализован алгоритм Форда-Беллмана для плотных графов. Результат показал, что при использовании списков смежности может ускорить алгоритм при работе с разряженными графами. Кроме того, в ходе экспериментов на скорость выполнения алгоритмов было установлено, что алгоритм при работе с объектами python list работает быстрее, чем с объектами python dict, что является оптимизацией алгоритма Форда-Беллмана.


