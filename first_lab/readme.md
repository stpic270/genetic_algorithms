# Введение
Алгоритм Форда-Беллмана позволяет найти кратчайшие пути из одной вершины графа до всех остальных, даже для графов, в которых веса ребер могут быть отрицательными. Тем не менее, в графе не должно быть циклов отрицательного веса, достижимых из начальной вершины, иначе вопрос о кратчайших путях является бессмысленным. 
Введем некоторые понятия, которые будут важны в последующем отчете: 
Пло́тный граф — граф, в котором число рёбер E близко к максимально возможному у полного графа с числом вершин V:

E = V(V-1)2

Граф, имеющий малое число рёбер, принято называть разреженным графом.
Вообще говоря, разница между разреженным и плотным графом условна и зависит от контекста. 

# Выполненная работа 
Алгоритм Форда-Беллмана использует динамическое программирование. Введем функцию динамического программирования:
F[k][i] — длина кратчайшего пути из начальной вершины до вершины i, содержащего не более k ребер.
Начальные значения зададим для случая k=0. В этом случае F[0][start] = 0, а для всех остальных вершин i F[0][i] = INF, то есть путь, состоящий из нуля ребер существует только от вершины start до вершины start, а до остальных вершин пути из нуля ребер не существует, что будем отмечать значением INF.
Далее будем вычислять значения функции F увеличивая число ребер в пути k, то есть вычислим кратчайшие пути, содержащие не более 1 ребра, кратчайшие пути, содержащие не более 2 ребер и т. д.
Рассмотрим, как вычисляется значение F[k][i]. Пусть есть кратчайший маршрут из вершины start до вершины i, содержащий не более k ребер. Пусть последнее ребро этого маршрута есть ребро j-i. Тогда путь до вершины j содержит не более k-1 ребра и является кратчайшим путем из всех таких путей, значит, его длина равна F[k-1][j], а длина пути до вершины i равна F[k-1][j] + edges[j][i], где edges[j][i] есть вес ребра j-i. Дальше необходимо перебрать все вершины j, которые могут выступать в качестве предыдущих, и выбрать минимальное значение F[k-1][j] + edges[j][i]. Также edges реализован как python list и содержит веса ребер для плотного графа.

Получается следующий алгоритм: 


Очевидно, что сложность такого алгоритма O(n3), т.к. подряд идут 3 вложенных цикла.

Рассмотрим реализацию алгоритма Форда-Беллмана с использованием списков смежности.
Пусть граф задан списками смежности, а вес ребра j-i хранится в словаре         W[j, i], где ключ — это кортеж из j, i, а значение — вес ребра. Тогда перебрать все ребра графа, можно организовав цикл по всем ключам словаря W и алгоритм Форда-Беллмана можно записать в виде:

Сложность такого алгоритма равна O(mn) , где  n - число вершин, m - число ребер графа. Видно, что для плотных графов (где mn2) сложность близка к сложности предыдущего варианта алгоритма, а вот для разреженных графов (где mn ) такой алгоритм будет существенно быстрее.
Однако в данной работе сгенерированные тесты представляют собой только плотные графы, при этом python немного быстрее работает с объектами list, чем с объектами dict. Поэтому использование list, вместо dict для плотных графов, используя алгоритм Форда-Беллмана является некоторой оптимизацией данного метода при заданных условиях. 
